<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="Generator" content="Microsoft Word 97">
<meta name="Template" content="F:\Program Files\Microsoft Office\Office\html.dot"></head>
<body link="#0000ff" vlink="#800080">

<b><font face="Arial" size="5"><p align="center">Компилятор “Странник” freeware.</p>
</font></b><font face="Arial" size="1"><p>Пару месяцев назад я получил
письмо от адресата из Соединенных Штатов. Он только что познакомился с
компилятором и написал следующее: </p>
</font><b><font face="Arial" size="2"><p>Your compiler is wonderful, …
The only problem is that I can not read the HELP FILE, is there a copy
somewhere that is in ENGLISH.</p>
</font></b><font face="Arial" size="1"><p>Я, разумеется, обнадежил его
сообщением, что вскоре искомый HELP будет переведен на английский, но
про себя подумал, что наши американские друзья, пожалуй, несколько
избалованы мировым компьютерным сообществом и привыкли читать
документацию только на родном языке.</p>
<p>Для разнообразия проект “Странник Модула-Си-Паскаль” полностью
русскоязычен. Интерфейс пользователя, языки программирования,
демонстрационные примеры, документация даже сами исходные тексты
компилятора написаны на русском языке. Ниже рассказано о применяемых
языках программирования, интегрированной среде и некоторых секретах
компиляции (внутреннняя структура компилятора и генерируемого им
exe-файла).</p>
</font><b><font face="Arial" size="5"><p align="center">1.Языки программирования.</p>
</font></b><font face="Arial"><h5 align="center">Общая семантика.</h5>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">В
настоящее время компилятор поддерживает три языка программирования –
Модула-2 (Оберон-2), Паскаль и Си (Си++). Все языки программирования
компилятора “Странник” имеют общую семантическую базу (одинаковый набор
операторов, базовых и производных типов, одинаковый механизм процедур и
модулей). Более подробно о языках с общей семантической базой можно
прочитать в статьях автора в Мире ПК (“Современные языки
программирования – результаты эволюции”, N3 за 2001) и Программисте
(“Сравнение языков программирования Си++, Паскаль и Ада”, N2 за 2002
год). Кратко можно сказать, что при приведении каждого языка к общей
семантической базе языки были частично сокращены, частично расширены.
Ниже приведен список конструкций, присутствующих во всех языках
программирования компилятора.</font></p>
<p><font face="Arial" size="1">	Операторы:</font></p>
<p><font face="Arial" size="1">1.Оператор присваивания</font></p>
<p><font face="Arial" size="1">2.Оператор вызова процедуры (функции)</font></p>
<p><font face="Arial" size="1">3.Условный оператор (<b>if</b>)</font></p>
<p><font face="Arial" size="1">4.Оператор выбора (<b>case, swith</b>)</font></p>
<p><font face="Arial" size="1">5.Цикл с параметром (<b>for</b>)</font></p>
<p><font face="Arial" size="1">6.Цикл с предусловием (<b>while</b>)</font></p>
<p><font face="Arial" size="1">7.Цикл с постусловием (<b>repeat, while do</b>)</font></p>
<p><font face="Arial" size="1">8.Оператор инкремента/декремента (<b>inc,dec,++,--</b>)</font></p>
<p><font face="Arial" size="1">9.Оператор выхода из процедуры/функции (<b>return,exit</b>)</font></p>
<p><font face="Arial" size="1">10.Оператор присоединения (<b>with</b>)</font></p>
<p><font face="Arial" size="1">11.Встроенный ассемблер (<b>asm</b>)</font></p>
<p><font face="Arial" size="1">	Простые типы данных:</font></p>
<p><font face="Arial" size="1">1.Целые размером 1 байт (<b>byte</b>), 2 байта (<b>word</b>), 4 байта (<b>integer, cardinal, int, dword, uint</b>)</font></p>
<p><font face="Arial" size="1">2.Символ (<b>char</b>)</font></p>
<p><font face="Arial" size="1">3.Логический (<b>boolean,bool</b>)</font></p>
<p><font face="Arial" size="1">4.Универсальный указатель (<b>address,void*</b>)</font></p>
<p><font face="Arial" size="1">5.Указатель на строку символов (<b>pstr,char*</b>)</font></p>
<p><font face="Arial" size="1">6.Строка символов (<b>string,char[]</b>)</font></p>
<p><font face="Arial" size="1">7.Числа с плавающей точкой размером 32 бита (<b>real32,float32</b>) и 64 бита (<b>real,float</b>)</font></p>
<p><font face="Arial" size="1">8.Множество размером 32 байта (<b>setbyte</b>)</font></p>
<p><font face="Arial" size="1">	Составные типы данных:</font></p>
<p><font face="Arial" size="1">1.Массивы</font></p>
<p><font face="Arial" size="1">2.Записи (структуры), в том числе с вариантной частью</font></p>
<p><font face="Arial" size="1">3.Указатели</font></p>
<p><font face="Arial" size="1">4.Скалярные типы (<b>enum</b>)</font></p>
<p><font face="Arial" size="1">5.Тип множество</font></p>
<p><font face="Arial" size="1">6.Классы и объекты</font></p>
<p><font face="Arial" size="1">&nbsp;</font></p>
<p><font face="Arial" size="1">	Процедуры (функции) и модули.</font></p>
<p><font face="Arial" size="1">Механизм процедур более или менее
идентичен во всех языках программирования и не подвергся какой-либо
переделке. При создании механизма модулей использовалась модель Си (и
Модулы), когда интерфейс модулей содержится в отдельном файле (h-файл в
Си и d-файл в Модуле). В то же время было принято решение отказаться от
практики Си, при которой импорт модуля осуществляется механическим
включением файла заголовка (h-файла) в текст программы. Это приводит к
необходимости все время перекомпилировать файлы заголовков, и, как
следствие, к большим затратам времени на компиляцию. Вместо этого
использована модель Модулы, когда файлы заголовков компилируются в
специальные интерфейсные файлы (i-файлы), которые затем могут
импортироваться даже при отсутствии самого файла заголовка.</font></p>
<p><font face="Arial" size="1">	Классы и объекты.</font></p>
<p><font face="Arial" size="1">Механизм объектно-ориентированного
программирования в современных языках программирования в настоящее
время можно считать устоявшимся. В качестве внешних атрибутов механизма
ООП были использованы языки Оберон-2 (для Модулы), Objective Pascal для
Паскаля и Си++ (для Си). Во всех языках программирования заголовки
методов (но не тела) можно включать в описание класса. Тела методов
описываются вне класса. Поля и методы могут иметь два уровня
инкапсуляции – <b>private</b> и <b>public. </b>Квалификатор <b>protected</b> в Си++ допустим, но эквивалентен <b>public</b>. Квалификатор <b>“-“</b> (экспорт только для чтения) в Оберон-2 допустим, но эквивалентен <b>public</b>-описанию. Все методы являются виртуальными, использование квалификатора <b>virtual</b>
в Си++ и Паскале допустимо, но компилятором игнорируется. Шаблоны
классов, дружественные методы и множественное наследование в Си++ не
реализованы. Переопределяемые методы должны иметь идентичный набор
параметров. Перегрузка имен методов (наличие двух методов с одинаковым
именем, но разным набором параметров) не допускается.</font></p>
<font face="Arial"><h4>Модула-2 (Оберон-2)</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">При
приведении Модулы-2 к общей семантической базе были исключены некоторые
редко используемые и отсутствующие в Си конструкции, вроде цикла LOOP,
а так же несколько упрощен механизм модулей и раздельной компиляции
(следует напомнить, что в Си он вообще отсутствует на уровне языка).</font></p>
<p><font face="Arial" size="1">Кроме того, была проведена унификация
лексических основ языков, скорректированная в сторону Си (например,
способы задания символьных, строковых или шестнадцатеричных констант
взяты из Си). Помимо соображений общности языков этому способствовала
идеология построения Win32, основанная на понятиях Си.</font></p>
<p><font face="Arial" size="1">В поставке компилятора так же
отсутствуют стандартные библиотечные модули Модулы, такие как InOut или
System. Предполагается, что программист будет использовать для целей
ввода-вывода или операций с файлами функции Win32.</font></p>
<p><font face="Arial" size="1">При реализации классов и объектов за
основу взяты механизмы языка Оберон-2, ставшего фактическим стандартом
реализации ООП в Модуле. При этом оператор WITH сохранил свою семантику
(т.е. по-прежнему предназначен для работы с записями, а не для проверки
типа объекта). Поскольку Модула-2 мощнее Оберон-2 во всем, что не
касается ООП, название языка сохранено, хотя реализацию Модулы-2 в
Страннике можно смело считать надмножеством языка Оберон-2.</font></p>
<p><img src="Image2.jpg" width="510" height="428"></p>
<font face="Arial"><h4 align="center">Рис.1 Фрагмент демонстрационного примера на Модуле</h4>
<h4>Си (Си++)</h4>
</font><font face="Arial" size="1"><p>В версию языка Си компилятора
Странник были внесены некоторые изменения, связанные с приведением
семантической базы языка в соответствие с семантикой языка Модула-2.
При этом на стандартные конструкции Си были наложены некоторые
ограничения. Так, например, нельзя использовать операции ++ и - внутри
выражения; ограничено применение директивы define. Наряду с
ограничениями, в Си были введены некоторые дополнительные конструкции:
типы bool, enum и set, elsif часть в операторе if, модернизирован
оператор выбора switch и другое.</p>
<p>Классы и объекты реализованы на основе механизмов Си++.</p>
<p>Все изменения, внесенные в язык, были сделаны с максимальным
вниманием к сохранению идеологии языка; как правило, конструкции эти
брались из родственных Си языков (таких, как Си++ и Ява).</p>
</font><p><img src="Image3.jpg" width="497" height="417"></p>
<b><font face="Arial" size="1"><p align="center">Рис.2 Фрагмент демонстрационного примера на Си++</p>
</font></b><font face="Arial"><h4>Паскаль</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">При
разработке версии языка Паскаль для компилятора Странник главной целью
разработчика была унификация семантических конструкций языка с другими
языками проекта Модулой и Си. В связи с близкой родственной связью
Паскаля с Модулой, модификация Паскаля не была существенной. Главное
изменение в семантике языковых конструкций связано с механизмом выхода
из функции. В Модуле и Си используется вариант оператора return, при
использовании которого выход из функции происходит сразу, в этом же
месте кода, и дальнейшие операторы не исполняются. В Паскале выход из
функции возможен только в конце кода функции, а результирующее значение
можно присваивать, как в обычном операторе присваивания. В Паскале для
компилятора Странник был использован вариант return, аналогичный Модуле
и Си. При этом внешний вид присваивания сохранен в паскалевском
варианте, однако последующие операторы не исполняются, а происходит
выход из функции.</font></p>
<p><font face="Arial" size="1">В случаях, когда классический Паскаль не
содержал необходимых конструкций, предпочтение отдавалось вариантам
этих конструкций из <b>Borland Pascal</b>. Так, заголовок модуля в Паскале для Странника выглядит как <b>UNIT</b> ИмяМодуля ,список импортируемых модулей, как <b>USES</b> СписокМодулей, а оператор выхода из процедуры как <b>EXIT</b>.</font></p>
<p><font face="Arial" size="1">Базовые типы данных (byte, char, word,
integer, address) в основном идентичны типам данных Модулы.
Единственное отличие - вместо типа cardinal введен тип dword</font></p>
<p><img src="Image4.jpg" width="497" height="417"><font face="Arial" size="1">.</font></p>
<font face="Arial" size="1"><b></b></font><p align="center"><font face="Arial" size="1"><b>Рис.3 Фрагмент демонстрационного примера на Паскале</b></font></p>
<font face="Arial"><h4>Встроенный ассемблер</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Инструкции
ассемблера Странника записываются в плавающем формате (допустима запись
нескольких инструкций в одной строке). Разделителем является точка с
запятой. Комментарии можно записывать после двух знаков косая черта
(комментарий в стиле Си++).</font></p>
<p><font face="Arial" size="1">Признак размера операнда можно указывать
после мнемоники команды. Допустимы следующие варианты размера: “b” или
“byte” (байт), “w” или “word” (слово),“d” или “dword” (двойное слово) и
“q” или “qword” (четырехсловный операнд).</font></p>
<p><font face="Arial" size="1">При задании операнда в памяти можно использовать имена переменных или параметров процедур с указанием ключевого слова offs. </font></p>
<p><font face="Arial" size="1">Встроенный ассемблер Странника позволяет
работать с сопроцессором Intel. Однако команды работы с сопроцессором
работают только с данными определенного размера, а именно:</font></p>
<p><font face="Arial" size="1">-	команды работы с целыми числами: 4-байтное целое</font></p>
<p><font face="Arial" size="1">-	команды работы с вещественными числами: 4 или 8-байтное вещественное</font></p>
<p><font face="Arial" size="1">-	команды работы с двоично-десятичными числами 10 байтное число</font></p>
<p><font face="Arial" size="1">В связи с этим указание размера операнда
в командах работы с плавающей точкой не допускается, за исключением
операций работы с вещественными числами (при работе с 32-бит числами
следует указывать размер “d” или “dword”, а для 64-битных чисел: “q”
или “qword”; по умолчанию применяется команда работы с 64-бит числами).</font></p>
<p><font face="Arial" size="1">Ассемблер Странника позволяет вставлять
в код непосредственные операнды, задаваемые с помощью шестнадцатеричных
или десятичных целых чисел.</font></p>
<p><img src="Image5.jpg" width="544" height="456"></p>
<b><font face="Arial" size="1"><p align="center">Рис.4 Встроенный ассемблер в Си</p>
</font></b><font face="Arial"><h4>Демонстрационные примеры.</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Набор
демонстрационных примеров компилятора делится на две группы. Первая
предназначена для демонстрации возможностей компилятора, вторая – для
демонстрации применения стандартных элементов интерфейса Wn32. Каждый
пример представляет из себя самостоятельную программу, состоящую из
одного файла объемом не более 200 строк (как правило, значительно
меньше). Каждый демонстрационный пример размножен в шести экземплярах –
три на русском (Модула, Си и Паскаль) и три на английском языке.</font></p>
<p><font face="Arial" size="1">Первая группа примеров состоит из следующих программ:</font></p>
<p><font face="Arial" size="1">Demo1_1 - простейшая программа (hello, word)</font></p>
<p><font face="Arial" size="1">Demo1_2 - простейшая программа с окном</font></p>
<p><font face="Arial" size="1">Demo1_3 - простейшая программа с окном и меню</font></p>
<p><font face="Arial" size="1">Demo1_4 - текстовый редактор ascii-файлов</font></p>
<p><font face="Arial" size="1">Demo1_5 - текстовый редактор rtf-файлов</font></p>
<p><font face="Arial" size="1">Demo1_6 - использование графических процедур GDI</font></p>
<p><font face="Arial" size="1">Demo1_7 - работа с эмулятором ДОС-терминала</font></p>
<p><font face="Arial" size="1">Demo1_8 - генератор случайных чисел</font></p>
<p><font face="Arial" size="1">Demo1_9 - получение командной строки программы</font></p>
<p><font face="Arial" size="1">Demo1_10 – Игра “теннис” (применение ООП)</font></p>
<p><font face="Arial" size="1">Вторая группа примеров:</font></p>
<p><font face="Arial" size="1">Demo2_1 - работа с деревьями (стандартный класс Treeview)</font></p>
<p><font face="Arial" size="1">Demo2_2 - работа со списком (стандартный класс Listview)</font></p>
<p><font face="Arial" size="1">Demo2_3 - индикатор progressbar</font></p>
<p><font face="Arial" size="1">Demo2_4 - индикатор trackbar</font></p>
<p><font face="Arial" size="1">Demo2_5 - проигрыватель avi-файлов</font></p>
<p><font face="Arial" size="1">Demo2_6 - стандартный диалог выбора файла</font></p>
<p><font face="Arial" size="1">Demo2_7 - кнопки Up=Down</font></p>
<p><font face="Arial" size="1">Demo2_8 - Конструктор WIZARD (каркас программы инсталляции)</font></p>
<p><font face="Arial" size="1">Demo2_9 - Диалог параметров (стандартный класс Options)</font></p>
<p><img src="Image6.jpg" width="517" height="294"></p>
<b><font face="Arial" size="1"><p align="center">Рис.5 Демонстрационный пример “Hello, world” на Си</p>
<p align="center">Размер генерируемого EXE-файла – 4 Кб.</p>
</font></b><font face="Arial"><h4>Дистрибутив компилятора.</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Дистрибутив
компилятора состоит из трех частей. В первую часть входит сам
компилятор и набор демонстрационных программ (объем в zip-архиве около
600 Кб). Вторая часть дистрибутива – исходные тексты компилятора на
Модуле (объем около 300 Кб). В третью часть дистрибутива входит
комплект альфа-тестов компилятора (многие из которых могут также
служить демонстрационными примерами). Объем третей части дистрибутива
около 100 Кб, он содержит около 100 тестов на каждом из языков
программирования, поддерживаемых компилятором.</font></p>
<p><font face="Arial" size="1">Компилятор поставляется в виде обычных
(не саморазархивирующихся) ZIP-архивов, не имеет программы установки и
не требует внесения каких-либо записей в реестр Windows.</font></p>
<p><font face="Arial" size="1">Получить компилятор можно с сайта автора по адресу </font><a href="http://home.perm.ru/%7Estrannik"><b><font face="Arial" size="1">home.perm.ru/~strannik</font></b></a><font face="Arial" size="1"> или с сайта <b>www.download.ru</b>.</font></p>
<p><font face="Arial" size="1">&nbsp;</font></p>
<b><font face="Arial" size="5"><p align="center">2.Интегрированная среда.</p>
</font></b><font face="Arial"><h4 align="center">Текстовый редактор</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Основой
интегрированной среды компилятора служит ситаксис-ориентированный
редактор программ. Отдельные элементы текста (ключевые слова,
комментарии, константы и т.д.) выделяются цветом и шрифтовым
оформлением. Для работы с проектами, состоящими из нескольких модулей
(файлов), существует два набора закладок. Первый набор отображает имена
загруженных в интегрированную среду модулей (файлов) и используется для
перехода от одного файла к другому. Во втором наборе всегда находятся
две закладки: для файла – заголовка модуля (h-файл в Си, d-файл в
Модуле или def-файл в Паскале); и для файла – тела модуля (c-файл в Си,
m-файл в Модуле или pas-файл в Паскале). Такая конструкция исключает
перегруженность традиционного многооконного интерфейса, когда для
каждого файла (будь то файл заголовка или файл тела модуля) открывалось
отдельное окно.</font></p>
<p><font face="Arial" size="1">В статус - строке компилятора помимо
информации и текущей строке и столбце находится информационная строка,
показывающая параметры процедуры (функции), над которой расположен
курсор, значение константы или другую текущую информацию.</font></p>
<p><font face="Arial" size="1">Текстовый редактор содержит механизм “отката” (отмены внесенных изменений).</font></p>
<p><font face="Arial" size="1">&nbsp;</font></p>
<p><img src="Image7.jpg" width="508" height="331"></p>
<b><font face="Arial" size="1"><p align="center">Рис.6 Интегрированная среда в момент выдачи сообщения об ошибке</p>
</font><font face="Arial"><p>Редактор диалогов</p>
</font></b><font face="Arial" size="1"></font><p><font face="Arial" size="1">Диалог
(dialog) – стандартный термин Win32, обозначающий окно с содержащими
его элементами, такими как кнопки, списки, однострочные редакторы и
другие элементы интерфейса. В Дельфи аналогичные объекты называются
“Формы”. Диалог состоит из двух компонент – собственно диалога и
диалоговой функции, описывающей реакцию программы на действия
пользователя. Для создания и редактирования диалога предназначен
встроенный редактор диалогов.</font></p>
<p><font face="Arial" size="1">В центре окна редактора диалогов
расположено изображение диалога со всеми элементами, а в нижней части
характеристики текущего элемента: текст, класс, идентификатор, размеры
и координаты.</font></p>
<p><font face="Arial" size="1">Переключение с одного элемента на другой, изменение их размеров и местоположения можно производить с помощью мыши.</font></p>
<p><font face="Arial" size="1">С помощью меню редактора диалогов можно
добавлять новые элементы в диалог (строки, кнопки, редакторы, списки и
другие). При выборе соответствующего пункта меню редактор создаст новый
элемент со стандартным для данного класса набором стилей.</font></p>
<p><font face="Arial" size="1">Редактор диалогов позволяет выделять и
манипулировать группами элементов. С выделенными элементами можно
работать с помощью меню Правка (копирование, вставка и удаление группы
элементов) и меню Выравнивание (выравнивание группы элементов по левому
и правому краю, по верху и низу, а так же выравнивание размеров
элементов по горизонтали и вертикали).</font></p>
<p><font face="Arial" size="1">Наиболее часто употребляемые пункты меню дублированы в линейке инструментов соответствующими кнопками.</font></p>
<p><font face="Arial" size="1">После закрытия редактора диалогов редактируемый диалог будет вставлен в текст программы или в clipboard.</font></p>
<p><font face="Arial" size="1">Помимо самого диалога Редактор диалогов
позволяет генерировать диалоговую функцию этого диалога, а так же вызов
диалога в тексте программы.</font></p>
<p><font face="Arial" size="1">Настройки редактора диалогов позволяют
дополнять список стандартных элементов, которые можно вставлять в
диалог, работая с редактором диалогов.</font></p>
<p><img src="Image8.jpg" width="496" height="262"></p>
<b><font face="Arial" size="1"><p align="center">Рис.7 Редактор диалогов</p>
</font></b><p><img src="Image9.jpg" width="482" height="315"></p>
<b><font face="Arial" size="1"><p align="center">Рис.8 Настройки редактора диалогов (классТекст)</p>
</font></b><font face="Arial"><h4>Отладчик</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Компилятор
содержит встроенный отладчик, позволяющий контролировать исполнение
отлаживаемой программы, приостанавливать ее исполнение и наблюдать
значения глобальных и локальных переменных.</font></p>
<p><font face="Arial" size="1">Существует четыре варианта запуска программы под отладчиком:</font></p>
<p><font face="Arial" size="1">“Запустить под отладчиком”, “Следующий
шаг”, “Следующий шаг (без входа в процедуру)” и “Перейти в текущую
строку”. В трех первых случаях программа будет остановлена на первой
строке исполняемого кода; в последнем - в строке, в которой находился
курсор в момент запуска отладчика. В статус - строке компилятора
появится надпись “Отладка” или “Ожидание”. Надпись “Ожидание” означает,
что компилятор ожидает от отлаживаемой программы достижения точки
останова. “Отладка” означает, что точка останова достигнута и
управление передано компилятору. В этот момент можно смотреть значения
локальных и глобальных переменных, запустить программу далее или
прервать отладку.</font></p>
<p><font face="Arial" size="1">Компилятор информирует о достижении точки останова миганием заголовка окна.</font></p>
<p><font face="Arial" size="1">Компилятор позволяет во время остановки
программы просматривать значения глобальных и локальных переменных. Для
этого предназначено диалоговое окно, в левой части которого
присутствуют два списка: глобальных и локальных переменных. Если
выбрать какое-либо имя одного из этих списков, в правой части окна
появится значение этой переменной. Если переменная является массивом
(структурой, записью) или комбинацией этих конструкций, можно
использовать окно доступа (в левой верхней части диалога) для доступа к
компонентам этой переменной. </font></p>
<p><font face="Arial" size="1">Следует отметить, что Странник не
вставляет никакой отладочной информации в exe-файл, а использует
информацию последней компиляции, поэтому перед запуском отладчика
программа всегда компилируется.</font></p>
<p><img src="Image10.jpg" width="349" height="270"></p>
<b><font face="Arial" size="1"><p align="center">Рис.9 Диалог просмотра значений переменных</p>
<p align="center">Вверху – список глобальных переменных, внизу – локальные переменные и параметры процедуры</p>
</font></b><font face="Arial"><h4>Справочная система</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Компилятор
обеспечивает информацией о любом идентификаторе программы при
использовании системы контекстной подсказки. Для получения контекстной
подсказки необходимо установить курсор на интересующий идентификатор и
нажать Ctrl+F1 или кнопку со знаком вопроса, после чего откроется окно
справки.</font></p>
<p><font face="Arial" size="1">В верхней части окна содержится искомый
идентификатор, непосредственно под ним расположен алфавитный список
всех идентификаторов, используемых в программе, включая все
импортируемые модули, в том числе и Win32. Список изначально пуст, и
чтобы загрузить его, следует нажать кнопку Загрузить. В правой части
окна расположено описание этого идентификатора (например, перечень
параметров процедуры или список полей записи (структуры)). Можно
получить справку по этому идентификатору из внешнего справочника по
Win32 (он задается через меню Настройки).</font></p>
<p><font face="Arial" size="1">В статус - строке в нижней части экрана
компилятора отображается расшифровка идентификатора, который расположен
непосредственно под курсором.</font></p>
<p><img src="Image11.jpg" width="417" height="376"></p>
<b><font face="Arial" size="1"><p align="center">Рис.10 Диалог контекстной подсказки</p>
<p align="center">Вверху – список модулей, в которых определен и использован идентификатор</p>
<p>&nbsp;</p>
</font><font face="Arial" size="5"><p align="center">3.Компилятор изнутри.</p>
</font></b><font face="Arial" size="1"><p>В этом разделе описаны
основные модули компилятора, главные структуры данных и процедуры, их
взаимодействие между собой. Исходные тексты компилятора состоят из 13
модулей общим объемом около 20000 строк текста (на Модуле).</p>
</font><font face="Arial"><h4>Модули компилятора</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Следующие модули составляют компилятор:</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>Win32ext.m</b> (ок. 900 строк) – стандартная библиотека функций ввода-вывода и операций преобразования типов</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmSys.m</b> (ок. 200 строк) – вспомогательные функции, не вошедшие в Win32ext</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmDat.m</b> (ок. 2500 строк) – модуль описания структур данных, инициализация и деинициализация</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmTab.m</b> (ок. 1000 строк) – работа с таблицей идентификаторов</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmGen.m</b> (ок. 2500 строк) – генератор кода</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmLex.m</b> (ок. 600 строк) – сканер (лексический анализатор)</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmAsm.m</b> (ок. 600 строк) – встроенный ассемблер</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmTra.m</b> (ок. 3500 строк) – транслятор выражения и языка Модула-2</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmTraC.m</b> (ок. 1700 строк) – транслятор языка Си (Си++)</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmTraP.m</b> (ок. 1000 строк) – транслятор языка Паскаль</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmRes.m</b> (ок. 2300 строк) – редактор диалогов</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>SmEnv.m</b> (ок. 5300 строк) – текстовый редактор, интегрированная среда и отладчик</font></p>
<font face="Arial" size="1"><b></b></font><p><font face="Arial" size="1"><b>Sm.m</b> (ок. 250 строк) – головной модуль</font></p>
<font face="Arial"><h4>Таблица идентификаторов</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Таблица
идентификаторов – главная структура данных компилятора. В ней хранится
информация обо всех объектах программы – переменных, константах, типах
данных, процедурах и функциях и т.д. Описание таблицы идентификаторов
содержится в модуле SmDat. Список различных вариантов идентификаторов
задает скалярный тип classId. Структура отдельного идентификатора
описана в записи (с вариантами) recId размером около 40 строк исходного
текста. Помимо специфических для каждого идентификатора полей
(например, процедура содержит список параметров, список локальных
переменных и тип возвращаемого значения) существуют и общие для всех
идентификаторов компоненты – имя, модуль, уровень инкапсуляции и другие.</font></p>
<p><font face="Arial" size="1">Каждый модуль программы (модули
содержатся в массиве tbMod) содержит собственную таблицу
идентификаторов, организованную в виде бинарного дерева.</font></p>
<p><font face="Arial" size="1">Процедуры работы с таблицей
идентификаторов расположены в модуле SmTab – инициализация и удаление
(idInitial, idDestroy), вставка и поиск идентификатора (idInsert,
idFind), эапись в файл и чтение из файла (idRead, idWrite).</font></p>
<p><img src="Image12.jpg" width="534" height="473"></p>
<b><font face="Arial" size="1"><p align="center">Рис.11 Фрагмент записи recID, содержащей информацию об идентификаторе</p>
</font></b><font face="Arial"><h4>Лексический анализ</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Лексический
анализ – самый “нижний” слой компилятора, призванный превратить текст
программы в поток лексем (ключевых слов, идентификаторов, констант,
разделителей и т.д.) На этом же этапе из текста программы исключаются
комментарии. Возможные виды лексем описаны в модуле SmDat в скалярном
типе classLex. Текущая лексема содержится в переменной типа recStream.</font></p>
<p><font face="Arial" size="1">Процедуры лексического анализа находятся
в модуле SmLex. Сам лексический анализ тоже содержит несколько уровней.
За самый низкий отвечает процедура lexNextLex, она превращает единицы
текста в лексемы. Процедура lexGetLex0 исключает из потока, полученного
от lexNextLex, комментарии. Процедура lexGetLex1 извлекает из потока,
получаемого от lexGetLex0, константные выражения, и превращает их в
обычные константы. На этом же этапе имена констант преобразуются в
константы. Таким образом, после преобразования потока лексем компилятор
на входе получает лексемы, в которых отсутствуют константные выражения
(уже сосчитанные процедурой lexGetLex1 и преобразованные в обычные
константы) и имена констант (так же преобразованные в обычные
константы).</font></p>
<p><font face="Arial" size="1">Помимо описанной выше группы процедур в
модуле SmLex содержится еще группа процедур внешнего анализа lexAccept0
и lexAccept1, которые аналогичны lexGetLex0 и lexGetLex1, но
дополнительно проверяют, соответствует ли полученная лексема ожидаемой,
и выдают ошибку в случае несоответствия. Трансляторы языков, как
правило, используют для лексического анализа именно эти процедуры.</font></p>
<font face="Arial"><h4>Трансляторы языков</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">При
трансляции языков используется т.н. “нисходящий рекурсивный разбор”,
когда для трансляции каждой конструкции языка (оператора, типа данных,
выражения) пишется отдельная процедура, а сама трансляция начинается с
самого верхнего уровня программы (модуля).</font></p>
<p><font face="Arial" size="1">Трансляторы языков программирования
находятся в модулях SmTra (Модула-2), SmTraC (Си) и SmTraP (Паскаль).
Самый большой модуль SmTra помимо транслятора собственно Модулы
содержит общий для всех языков транслятор выражений (процедура
traEXPRESSION, около 1000 строк текста). Помимо транслятора выражений
модуль содержит трансляторы операторов языка (процедуры traFOR, traIF,
traCASE и т.д.), трансляторы описаний типов, констант и переменных
(traRECORD, traARRAY и т.п.), и транслятор описаний процедур (traPROC,
ок. 300 строк текста). Трансляторы языков Си и Паскаль содержат
аналогичные процедуры для трансляции конструкций, отличающихся от
конструкций Модулы (например, транслятор описания процедуры для Си
называется tracPROC, для Паскаля – trapPROC).</font></p>
<p><font face="Arial" size="1">Главной процедурой во всех трех
трансляторах служит трансляция модуля (файла) traMODULE (для Си и
Паскаля tracMODULE и trapMODULE соответственно). Именно они
используются интегрированной средой при компиляции программы.</font></p>
<p><img src="Image13.jpg" width="508" height="451"></p>
<b><font face="Arial" size="1"><p align="center">Рис.12 Транслятор заголовка функции в Си (модуль SmTraC)</p>
</font></b><font face="Arial"><h4>Генератор кода</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Генератор
кода (файл SmGen) состоит из двух основных групп процедур: группы
генераторов ассемблерных команд и генератора EXE-файла. Генераторы
ассемблерных команд разбиты по классам команд – команды без параметров
(процедура genGen), команды с параметром – регистром (genR), команды
регистр – память (genRM) и т.п. Виды команд описаны в модуле SmDat в
скалярном типе classCommand. Их ассемблерные имена и коды содержатся в
структурной константе asmCommands.</font></p>
<p><font face="Arial" size="1">В общем случае команда процессора Intel
состоит из байта команды, (возможно) постбайта, кодирующего регистры
или способ адресации памяти, (возможно) 1,2 или 4 байтового смещения и
(возможно) 1,2 или 4-байтового непосредственного операнда. Таким
образом одна команда может иметь длину от 1 (например, NOP) до 10 байт
(например MOV [ESI+0xFFFFFFFF],0xFFFFFFFF).</font></p>
<p><font face="Arial" size="1">EXE-файл Win32 состоит из заголовка,
таблицы секций и содержимого секций (более подробно его структура
описана ниже). EXE-файл создает процедура genEXE, однако основной
является процедура genConstruct (около 600 строк), которая
последовательно создает весь файл за исключением заголовка,
генерируемого процедурой genWinHeader.</font></p>
<p><font face="Arial" size="1">Процедуры genDef и genImp из модуля
SmGen создают и читают интерфейсные файлы модулей (i-файлы).
Интерфейсный файл содержит код модуля, его таблицу идентификаторов,
списки вызовов переменных и процедур и отладочную информацию.</font></p>
<font face="Arial"><h4>Редактор диалогов</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Модуль
редактора диалогов экспортирует всего 2 процедуры – ресКоррДиалог
(изменение/создание диалога) и ресНастройки (настройки редактора
диалогов). Однако сам модуль получился довольно объемным из-за набора
дополнительных функций, относящихся к диалогам. Примерно треть модуля
составляют процедуры генерации текста диалоговой функции для каждого из
языков программирования (и для двух языков общения – русского и
английского), трансляции текста программы в диалог и обратно.</font></p>
<p><font face="Arial" size="1">Сам редактируемый диалог содержится в глобальной переменной resDld.</font></p>
<p><font face="Arial" size="1">Изображаемый диалог представляет из себя
дочернее окно (как и все элементы диалога), поэтому для них были
написаны оконные функции элемента (ресПроцЭлем) и диалога (ресПроцДлг).</font></p>
<p><font face="Arial" size="1">Собственно редактор диалогов тоже представляет из себя диалог с диалоговой функцией ресПроцРесурсы.</font></p>
<p><font face="Arial" size="1">Остальная часть модуля занята функциями редактирования диалога – работа с блоками элементов, выравнивание и т.п.</font></p>
<p><img src="Image14.jpg" width="425" height="312"></p>
<b><font face="Arial" size="1"><p align="center">Рис.13 Интерфейсный файл редактора диалогов SmRes</p>
</font></b><font face="Arial"><h4>Текстовый редактор</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Название
“Тестовый редактор” в случае компилятора “Странник” не совсем
корректно, поскольку внутреннее представление текста программ – не
текст, а массив строк, каждая из которых состоит из массива лексем (или
отрезков). Внешнее представление программ осталось традиционным
(текстовые файлы). Поэтому на этапе загрузки и выгрузки файлов должны
проводиться соответствующие преобразования (текст-отрезки и
отрезки-текст). За них ответственны процедуры envToFrag (текст-отрезки
для одной строки) и envFromFrag (отрезки-текст для одной строки).</font></p>
<p><font face="Arial" size="1">Структура строки и отрезка описана в
модуле SmDat (запись с вариантами recFrag для отрезка и запись recText
для текста программы).</font></p>
<p><font face="Arial" size="1">Существенную часть редактора (ок. 500
строк) занимают процедуры отображения текста на экране, основные из
которых – процедура отображения текста отрезка envViewOtr и процедура
отображения всего экрана envView.</font></p>
<p><font face="Arial" size="1">Около 1000 строк текста занимают
процедуры изменения текста программы – работа с блоками, перемещение
курсора, поиск и замена, вставка и удаление символа и другие.</font></p>
<p><font face="Arial" size="1">Систему контекстной подсказки реализует процедура envIdentifier.</font></p>
<font face="Arial"><h4>Отладчик</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Процедуры
отладчика (как и процедуры тестового редактора) содержатся в модуле
SmEnv и занимают около 1000 строк исходного текста. Механизм отладки
основан на встроенной в Win32 подсистеме отладки приложений, состоящей
из функций DebugBreak (вызов отладчика из отлаживаемой программы),
WaitForDebugEvent (ожидание вызова в отладчике), ContinueDebugEvent
(продолжение исполнения отлаживаемой программы после остановки),
ReadProcessMemory и WriteProcessMemory (чтение и запись данных из
отлаживаемой программы).</font></p>
<p><font face="Arial" size="1">Основную техническую сложность
составляет необходимость модифицировать код отлаживаемой программы для
вставки вызова функции DebugBreak. Сам вызов занимает 5 байт кода (байт
команды и 4 байта адреса), следовательно, эти 5 байт следует запомнить
в специальном буфере. Сама модификация кода производится с помощью
функции WriteProcessMemory. Вставку инструкции в код осуществляет
процедура ВставитьИнструкциюВКод. Еще одну проблему составляет то, что
после вызова DebugBreak адрес текущей команды (регистр EIP процессора)
будет установлен на 5 байтов дальше, чем это необходимо. Поэтому перед
продолжением выполнения отлаживаемой программы необходимо (помимо
восстановления кода программы) изменить значение регистра EIP. Напрямую
этого сделать нельзя, поэтому используется следующая схема: в то место,
на которое указывает EIP, вставляется инструкция перехода JMP на десять
байт назад. В место перехода вставляется новый вызов DebugBreak, после
которого значение EIP будет уже верным. Таким образом, обработка одной
точки останова состоит из двух этапов (двух вызовов DebugBreak).</font></p>
<p><font face="Arial" size="1">Вторая важная задача – это определение
следующей точки останова при пошаговой отладке. Поскольку программа
состоит из ветвлений (операторов <b>if, case, switch</b>, циклов и т.д.), заранее невозможно предсказать, какой будет следующая точка останова (например, какой из вариантов <b>case</b>
будет выбран). Поэтому необходимо ставить точки останова в каждый
возможный вариант, а после останова убирать лишние точки. Отвечает за
установку точек прерывания процедура отлРасставитьBreak, а за удаление
– отлЛиквидироватьBreak.</font></p>
<p><font face="Arial" size="1">Сами точки останова хранятся в массивах
genStep в каждом модуле (описание массива arrStep содержится в модуле
SmDat). Активные в данный момент точки останова хранятся в массиве
stepActive.</font></p>
<p><font face="Arial" size="1">Возможные виды точек останова описаны в скалярном типе classStep.</font></p>
<p><font face="Arial" size="1">Отдельной задачей отладки является показ
содержимого переменных (глобальных и локальных). Первая трудность –
необходимость определить адрес переменной. Для глобальных переменных
это несложно (адрес секции данных известен, смещение внутри секции
можно определить по данным компиляции). Для определения адреса
локальной переменной необходимо сначала получить адрес кадра стека,
который хранится в регистре EBP. За эту операцию отвечает процедура
отлПолучитьЗначениеBP, использующая функцию GetThreadContext. Само
значение переменной извлекается из отлаживаемой программы с помощью
функции ReadProcessMemory.</font></p>
<p><font face="Arial" size="1">Вторая задача – преобразовать полученный
байтовый массив в текст, пригодный для показа. Эту проблему решают
процедуры отлПеремВТекст и отлТипВТекст.</font></p>
<p><font face="Arial" size="1">&nbsp;</font></p>
<b><font face="Arial" size="5"><p align="center">4.Exe (dll) файл изнутри.</p>
</font></b><font face="Arial" size="1"><p>В этом разделе рассказано о структуре exe (dll) файла, создаваемого компилятором Странник.</p>
</font><font face="Arial"><h4>Общая структура exe-файла</h4>
</font><font face="Arial" size="1"></font><p><font face="Arial" size="1">Exe-файл,
создаваемый компилятором, состоит из заголовка и пяти секций - кода,
данных, экспорта и импорта, ресурсов. Все секции выравниваются на
границу 0x200 байт (а при загрузке в память – на 0x1000 байт, таким
образом, при загрузке “на выполнение” exe-файл “растягивается”).
Заголовок файла (структура recWinHeader из модуля SmDat плюс таблица
секций) заполняется в первую очередь. Как правило, все поля имеют
стандартное содержание, за исключением полей flags (для DLL должен быть
установлен флаг 0x2000), и полей размеров: sizeOfCode (размер кода),
sizeOfUnIniData (размер данных), entryPoint (адрес начальной инструкции
кода), baseOfCode (начало секции кода), sizeofImage (размер
загруженного exe-файла), sizeofHeaders (размер заголовка). В конце
заголовка содержится структура DataDirectory (16 8-байтных полей).
Заполняются только первые три поля, соответствующие секциям экспорта,
импорта и ресурсов.</font></p>
<p><font face="Arial" size="1">Сразу после WinHeader следует таблица
секций – 5 структур из массива tbSection. Для каждой секции заполняются
ее название, адрес в файле, адрес после загрузки файла и флаги.</font></p>
<p><font face="Arial" size="1">Процедура genWinHeader из модуля SmGen отвечает за создание заголовка exe-файла.</font></p>
<p><font face="Arial" size="1">Заголовок и каждая секция файла выравниваются на границу 0x200 (процедура genWriteAlign).</font></p>
<p><img src="Image15.jpg" width="399" height="620"></p>
<b><font face="Arial" size="1"><p align="center">Рис.14 Общая структура EXE-файла</p>
</font><font face="Arial"><p>Секция данных (.data)</p>
</font></b><font face="Arial" size="1"></font><p><font face="Arial" size="1">Сразу
после заголовка файла следует секция данных. Благодаря этому адрес
секции данных всегда на 0x1000 байт больше начала exe-файла. А
поскольку exe-файл (но не DLL!) всегда загружается по адресу 0x400000,
то адрес начала секции данных всегда 0x401000.</font></p>
<p><font face="Arial" size="1">В секции данных выделяется память под
глобальные переменные и хранятся строковые и структурные
(типизированные) константы. Секция данных собирается из данных модулей
компилируемой программы (массивы genData из массива модулей tbMod).
Перед тем, как данные записываются в файл, в них происходит коррекция
адресов данных из других модулей, которые не могли быть известны во
время компиляции модуля. Эти поправки хранятся в массивах genVarCall из
массива модулей tbMod.</font></p>
<p><font face="Arial" size="1">Секция данных (как и все остальные секции) генерируется в процедуре genConstruct из модуля SmGen.</font></p>
<b><font face="Arial"><p>Секции экспорта и импорта (.edata и .idata)</p>
</font></b><font face="Arial" size="1"><p>Секция экспорта заполняется
только в DLL-файле и предназначена для хранения списка экспортируемых
функций. Сама секция состоит из заголовка (структура
imageExportDesctriptor) и четырех таблиц: таблицы адресов функций,
таблицы адресов имен функций, таблицы номеров функций и таблицы имен
функций.</p>
<p>Секция импорта хранит имена функций внешних DLL-библиотек (в
частности, функций Win32), вызываемых программой. Структура ее
значительно сложнее структуры секции экспорта. Кратко можно сказать,
что секция импорта состоит из набора записей (imageImportDesctriptor),
каждая из которых соответствует одной DLL-библиотеке. Каждой библиотеке
соотвествует набор записей о функциях: имя функции и нулевое 4-х
байтное поле, в которое Windows при загрузке EXE-файла запишет адрес
искомой функции. Именно на это поле (адрес в секции импорта) ссылается
каждый вызов внешней функции в программе (поэтому для вызова внешних
функций используется инструкция “косвенный CALL” с кодом 0xFF).</p>
</font><b><font face="Arial"><p>Секция кода (.text)</p>
</font></b><font face="Arial" size="1"></font><p><font face="Arial" size="1">Эта
секция содержит код программы. Секция формируется из кодов модулей
(структура genCode из массива модулей tbMod), слева направо. Перед
записью очередной порции кода в файл производится расстановка адресов
вызовов внешних DLL-функций (хранятся в структуре genImport из массива
tbMod), вызовов внешних (для данного модуля) процедур и методов
(хранятся в genProCall) и обращений к глобальным переменным и
структурным константам (структура genVarCall из tbMod).</font></p>
<b><font face="Arial"><p>Секция ресурсов (.rsrc)</p>
</font></b><font face="Arial" size="1"><p>Самую сложную структуру имеет
секция ресурсов EXE-файла, хотя назначение ее ограничено – в ней
хранятся диалоги, иконки и BMP-изображения, используемые программой.
Сложность организации секции ресурсов обусловлена ее древовидной
структурой (аналогичной файловой системе Windows), содержащей корневой
каталог и неограниченное число подкаталогов, в которых могут быть свои
подкаталоги.</p>
<p>В секции ресурсов файла, генерируемого компилятором Странник ,
содержится всего 4 подкаталога (структура
image_resource_directory_entry), содержащих диалоги, BMP-картинки,
иконки и группы иконок. Следом за подкаталогами следуют каталоги
(структура image_resource_directory), затем “входы” по количеству
каждого из элементов (диалогов и т.п.), имена элементов и только потом
– собственно элементы (“образы” в терминологии Win32).</p>
</font><font size="1"><p>&nbsp;</p>
</font><b><font face="Arial" size="5"></font></b><p align="center"><b><font face="Arial" size="5">Перспективы.</font></b></p>
<font face="Arial" size="1"><p>Конечной целью проекта является создание
многоязычного компилятора с нетекстовой интегрированной средой
(частично этому вопросу была посвящена статья в Мире ПК 3 за 2001 г.).
В такой среде внутреннее представление программы должно представлять
древовидную структуру (модуль – процедуры – операторы – выражение и
т.д.). Внешне программа по-прежнему будет выглядеть как текст на
каком-либо языке программирования. В этом случае само понятие языка
программирования нивелируется, поскольку перейти (и перевести
программу) с одного языка на другой можно будет простым переключением
соответствующих настроек компилятора. Разумеется, список применяемых
языков в этом случае можно расширять до бесконечности. Существенно
упрощается и ускоряется в этом случае и сама компиляция, поскольку
отпадают самые “ресурсоемкие” стадии компиляции – лексический и
синтаксический разбор. Разумеется, сочетать внутреннюю древовидную
структуру с внешним представлением в виде текста крайне сложно, поэтому
пока компилятор имеет традиционный текстовый интерфейс, однако создание
нового интерфейса – главная задача автора на ближайшую перспективу.</p></font></body></html>